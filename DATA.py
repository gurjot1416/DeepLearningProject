# -*- coding: utf-8 -*-
"""astro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vNG-zsTdj_WEOWkAJJYHBGOe2nmmjj04
"""

pip install astroNN

from astroNN.datasets import load_galaxy10
from tensorflow.keras import utils
import numpy as np
from sklearn.model_selection import StratifiedShuffleSplit

# Load images and labels (will download automatically the first time)
images, labels = load_galaxy10()

# Convert the labels to categorical 10 classes
labels_categorical = utils.to_categorical(labels, 10)

# Convert to desirable type
labels_categorical = labels_categorical.astype(np.float32)
images = images.astype(np.float32)

# Split the dataset into training and testing sets while maintaining class distribution
sss = StratifiedShuffleSplit(n_splits=1, test_size=0.1, random_state=0)
for train_idx, test_idx in sss.split(images, labels):
    train_images, train_labels = images[train_idx], labels_categorical[train_idx]
    test_images, test_labels = images[test_idx], labels_categorical[test_idx]

# Import Image from PIL for image processing
from PIL import Image
import os

# Function to save images remains the same
def save_images(images, labels, base_folder="Galaxy10_images"):
    # Ensure base directory exists
    if not os.path.exists(base_folder):
        os.makedirs(base_folder)

    # Loop through each image and its corresponding label
    for idx, (image, label) in enumerate(zip(images, np.argmax(labels, axis=1))):
        # Define the directory name based on the label
        directory = os.path.join(base_folder, str(label))
        # Ensure this directory exists
        if not os.path.exists(directory):
            os.makedirs(directory)

        # Normalize and scale the image to uint8
        normalized_image = ((image - np.min(image)) / (np.max(image) - np.min(image))) * 255
        image_uint8 = normalized_image.astype('uint8')

        # Create an image from the numpy array
        image_pil = Image.fromarray(image_uint8)

        # Define the file name
        file_name = f"image_{idx}.png"

        # Save the image in the corresponding labeled folder
        image_pil.save(os.path.join(directory, file_name))

# Usage of save_images function remains the same
save_images(train_images, train_labels, base_folder="Galaxy10_train_images")
save_images(test_images, test_labels, base_folder="Galaxy10_test_images")

# Function to count images in folders remains the same
import os

def count_images_in_folders(base_folder):
    # Dictionary to hold the count of images per label
    label_counts = {}

    # List all items in the base folder
    for label_folder in os.listdir(base_folder):
        label_folder_path = os.path.join(base_folder, label_folder)

        # Check if the item is a directory
        if os.path.isdir(label_folder_path):
            # Count the number of image files in this directory
            count = len([name for name in os.listdir(label_folder_path) if os.path.isfile(os.path.join(label_folder_path, name))])
            label_counts[label_folder] = count

    return label_counts

# Usage
train_counts = count_images_in_folders("Galaxy10_train_images")
test_counts = count_images_in_folders("Galaxy10_test_images")

print("Training set counts per class:", train_counts)
print("Test set counts per class:", test_counts)

# Usage of count_images_in_folders function remains the same

# Now you can continue to save your images and count them as before
save_images(train_images, train_labels, base_folder="Galaxy10_train_images")
save_images(test_images, test_labels, base_folder="Galaxy10_test_images")

# After saving, you can count the images in each folder to verify the stratified distribution
train_counts = count_images_in_folders("Galaxy10_train_images")
test_counts = count_images_in_folders("Galaxy10_test_images")

print("Training set counts per class:", train_counts)
print("Test set counts per class:", test_counts)

!zip -r Galaxy10_train_images.zip Galaxy10_train_images
!zip -r Galaxy10_test_images.zip Galaxy10_test_images

